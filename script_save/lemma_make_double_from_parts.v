(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.Rbasic_fun.
Require Reals.R_sqrt.
Require Reals.Rtrigo_def.
Require Reals.Rpower.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require int.Power.
Require real.Real.
Require real.RealInfix.
Require real.Abs.
Require real.FromInt.
Require real.Square.
Require real.ExpLog.
Require real.PowerReal.
Require map.Map.
Require bv.Pow2int.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.true) <-> (x = y).

Axiom eqb_false :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.false) <-> ~ (x = y).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((neqb x y) = Init.Datatypes.true) <-> ~ (x = y).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zlt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom zleq1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zleq x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rlt x y) = Init.Datatypes.true) <-> (x < y)%R.

Axiom rleq1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rleq x y) = Init.Datatypes.true) <-> (x <= y)%R.

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

Axiom abs_def :
  forall (x:Numbers.BinNums.Z),
  ((0%Z <= x)%Z -> ((ZArith.BinInt.Z.abs x) = x)) /\
  (~ (0%Z <= x)%Z -> ((ZArith.BinInt.Z.abs x) = (-x)%Z)).

Axiom sqrt_lin1 :
  forall (x:Reals.Rdefinitions.R), (1%R < x)%R ->
  ((Reals.R_sqrt.sqrt x) < x)%R.

Axiom sqrt_lin0 :
  forall (x:Reals.Rdefinitions.R), (0%R < x)%R /\ (x < 1%R)%R ->
  (x < (Reals.R_sqrt.sqrt x))%R.

Axiom sqrt_0 : ((Reals.R_sqrt.sqrt 0%R) = 0%R).

Axiom sqrt_1 : ((Reals.R_sqrt.sqrt 1%R) = 1%R).

(* Why3 assumption *)
Inductive mode :=
  | RNE : mode
  | RNA : mode
  | RTP : mode
  | RTN : mode
  | RTZ : mode.
Axiom mode_WhyType : WhyType mode.
Existing Instance mode_WhyType.

(* Why3 assumption *)
Definition to_nearest (m:mode) : Prop := (m = RNE) \/ (m = RNA).

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter t'real: t -> Reals.Rdefinitions.R.

Parameter t'isFinite: t -> Prop.

Axiom t'axiom :
  forall (x:t), t'isFinite x ->
  ((-340282346638528859811704183484516925440%R)%R <= (t'real x))%R /\
  ((t'real x) <= 340282346638528859811704183484516925440%R)%R.

Parameter truncate: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom Truncate_int :
  forall (i:Numbers.BinNums.Z), ((truncate (BuiltIn.IZR i)) = i).

Axiom Truncate_down_pos :
  forall (x:Reals.Rdefinitions.R), (0%R <= x)%R ->
  ((BuiltIn.IZR (truncate x)) <= x)%R /\
  (x < (BuiltIn.IZR ((truncate x) + 1%Z)%Z))%R.

Axiom Truncate_up_neg :
  forall (x:Reals.Rdefinitions.R), (x <= 0%R)%R ->
  ((BuiltIn.IZR ((truncate x) - 1%Z)%Z) < x)%R /\
  (x <= (BuiltIn.IZR (truncate x)))%R.

Axiom Real_of_truncate :
  forall (x:Reals.Rdefinitions.R),
  ((x - 1%R)%R <= (BuiltIn.IZR (truncate x)))%R /\
  ((BuiltIn.IZR (truncate x)) <= (x + 1%R)%R)%R.

Axiom Truncate_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((truncate x) <= (truncate y))%Z.

Axiom Truncate_monotonic_int1 :
  forall (x:Reals.Rdefinitions.R) (i:Numbers.BinNums.Z),
  (x <= (BuiltIn.IZR i))%R -> ((truncate x) <= i)%Z.

Axiom Truncate_monotonic_int2 :
  forall (x:Reals.Rdefinitions.R) (i:Numbers.BinNums.Z),
  ((BuiltIn.IZR i) <= x)%R -> (i <= (truncate x))%Z.

Parameter floor: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Parameter ceil: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom Floor_int :
  forall (i:Numbers.BinNums.Z), ((floor (BuiltIn.IZR i)) = i).

Axiom Ceil_int : forall (i:Numbers.BinNums.Z), ((ceil (BuiltIn.IZR i)) = i).

Axiom Floor_down :
  forall (x:Reals.Rdefinitions.R),
  ((BuiltIn.IZR (floor x)) <= x)%R /\
  (x < (BuiltIn.IZR ((floor x) + 1%Z)%Z))%R.

Axiom Ceil_up :
  forall (x:Reals.Rdefinitions.R),
  ((BuiltIn.IZR ((ceil x) - 1%Z)%Z) < x)%R /\ (x <= (BuiltIn.IZR (ceil x)))%R.

Axiom Floor_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((floor x) <= (floor y))%Z.

Axiom Ceil_monotonic :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x <= y)%R ->
  ((ceil x) <= (ceil y))%Z.

Parameter zeroF: t.

Parameter add: mode -> t -> t -> t.

Parameter sub: mode -> t -> t -> t.

Parameter mul: mode -> t -> t -> t.

Parameter div: mode -> t -> t -> t.

Parameter abs: t -> t.

Parameter neg: t -> t.

Parameter fma: mode -> t -> t -> t -> t.

Parameter sqrt: mode -> t -> t.

Parameter roundToIntegral: mode -> t -> t.

Parameter min: t -> t -> t.

Parameter max: t -> t -> t.

Parameter le: t -> t -> Prop.

Parameter lt: t -> t -> Prop.

Parameter eq: t -> t -> Prop.

Parameter is_normal: t -> Prop.

Parameter is_subnormal: t -> Prop.

Parameter is_zero: t -> Prop.

Parameter is_infinite: t -> Prop.

Parameter is_nan: t -> Prop.

Parameter is_positive: t -> Prop.

Parameter is_negative: t -> Prop.

(* Why3 assumption *)
Definition is_plus_infinity (x:t) : Prop := is_infinite x /\ is_positive x.

(* Why3 assumption *)
Definition is_minus_infinity (x:t) : Prop := is_infinite x /\ is_negative x.

(* Why3 assumption *)
Definition is_plus_zero (x:t) : Prop := is_zero x /\ is_positive x.

(* Why3 assumption *)
Definition is_minus_zero (x:t) : Prop := is_zero x /\ is_negative x.

(* Why3 assumption *)
Definition is_not_nan (x:t) : Prop := t'isFinite x \/ is_infinite x.

Axiom is_not_nan1 : forall (x:t), is_not_nan x <-> ~ is_nan x.

Axiom is_not_finite :
  forall (x:t), ~ t'isFinite x <-> is_infinite x \/ is_nan x.

Axiom zeroF_is_positive : is_positive zeroF.

Axiom zeroF_is_zero : is_zero zeroF.

Axiom zero_to_real :
  forall (x:t), is_zero x <-> t'isFinite x /\ ((t'real x) = 0%R).

Parameter of_int: mode -> Numbers.BinNums.Z -> t.

Parameter to_int: mode -> t -> Numbers.BinNums.Z.

Axiom zero_of_int : forall (m:mode), (zeroF = (of_int m 0%Z)).

Parameter round: mode -> Reals.Rdefinitions.R -> Reals.Rdefinitions.R.

Parameter max_int: Numbers.BinNums.Z.

Axiom max_real_int :
  ((33554430 * 10141204801825835211973625643008)%R = (BuiltIn.IZR max_int)).

(* Why3 assumption *)
Definition in_range (x:Reals.Rdefinitions.R) : Prop :=
  ((-(33554430 * 10141204801825835211973625643008)%R)%R <= x)%R /\
  (x <= (33554430 * 10141204801825835211973625643008)%R)%R.

(* Why3 assumption *)
Definition in_int_range (i:Numbers.BinNums.Z) : Prop :=
  ((-max_int)%Z <= i)%Z /\ (i <= max_int)%Z.

Axiom is_finite : forall (x:t), t'isFinite x -> in_range (t'real x).

(* Why3 assumption *)
Definition no_overflow (m:mode) (x:Reals.Rdefinitions.R) : Prop :=
  in_range (round m x).

Axiom Bounded_real_no_overflow :
  forall (m:mode) (x:Reals.Rdefinitions.R), in_range x -> no_overflow m x.

Axiom Round_monotonic :
  forall (m:mode) (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  (x <= y)%R -> ((round m x) <= (round m y))%R.

Axiom Round_idempotent :
  forall (m1:mode) (m2:mode) (x:Reals.Rdefinitions.R),
  ((round m1 (round m2 x)) = (round m2 x)).

Axiom Round_to_real :
  forall (m:mode) (x:t), t'isFinite x -> ((round m (t'real x)) = (t'real x)).

Axiom Round_down_le :
  forall (x:Reals.Rdefinitions.R), ((round RTN x) <= x)%R.

Axiom Round_up_ge : forall (x:Reals.Rdefinitions.R), (x <= (round RTP x))%R.

Axiom Round_down_neg :
  forall (x:Reals.Rdefinitions.R), ((round RTN (-x)%R) = (-(round RTP x))%R).

Axiom Round_up_neg :
  forall (x:Reals.Rdefinitions.R), ((round RTP (-x)%R) = (-(round RTN x))%R).

(* Why3 assumption *)
Definition in_safe_int_range (i:Numbers.BinNums.Z) : Prop :=
  ((-16777216%Z)%Z <= i)%Z /\ (i <= 16777216%Z)%Z.

Axiom Exact_rounding_for_integers :
  forall (m:mode) (i:Numbers.BinNums.Z), in_safe_int_range i ->
  ((round m (BuiltIn.IZR i)) = (BuiltIn.IZR i)).

(* Why3 assumption *)
Definition same_sign (x:t) (y:t) : Prop :=
  is_positive x /\ is_positive y \/ is_negative x /\ is_negative y.

(* Why3 assumption *)
Definition diff_sign (x:t) (y:t) : Prop :=
  is_positive x /\ is_negative y \/ is_negative x /\ is_positive y.

Axiom feq_eq :
  forall (x:t) (y:t), t'isFinite x -> t'isFinite y -> ~ is_zero x ->
  eq x y -> (x = y).

Axiom eq_feq :
  forall (x:t) (y:t), t'isFinite x -> t'isFinite y -> (x = y) -> eq x y.

Axiom eq_refl : forall (x:t), t'isFinite x -> eq x x.

Axiom eq_sym : forall (x:t) (y:t), eq x y -> eq y x.

Axiom eq_trans : forall (x:t) (y:t) (z:t), eq x y -> eq y z -> eq x z.

Axiom eq_zero : eq zeroF (neg zeroF).

Axiom eq_to_real_finite :
  forall (x:t) (y:t), t'isFinite x /\ t'isFinite y ->
  eq x y <-> ((t'real x) = (t'real y)).

Axiom eq_special :
  forall (x:t) (y:t), eq x y ->
  is_not_nan x /\
  is_not_nan y /\
  (t'isFinite x /\ t'isFinite y \/
   is_infinite x /\ is_infinite y /\ same_sign x y).

Axiom lt_finite :
  forall (x:t) (y:t), t'isFinite x /\ t'isFinite y ->
  lt x y <-> ((t'real x) < (t'real y))%R.

Axiom le_finite :
  forall (x:t) (y:t), t'isFinite x /\ t'isFinite y ->
  le x y <-> ((t'real x) <= (t'real y))%R.

Axiom le_lt_trans : forall (x:t) (y:t) (z:t), le x y /\ lt y z -> lt x z.

Axiom lt_le_trans : forall (x:t) (y:t) (z:t), lt x y /\ le y z -> lt x z.

Axiom le_ge_asym : forall (x:t) (y:t), le x y /\ le y x -> eq x y.

Axiom not_lt_ge :
  forall (x:t) (y:t), ~ lt x y /\ is_not_nan x /\ is_not_nan y -> le y x.

Axiom not_gt_le :
  forall (x:t) (y:t), ~ lt y x /\ is_not_nan x /\ is_not_nan y -> le x y.

Axiom le_special :
  forall (x:t) (y:t), le x y ->
  t'isFinite x /\ t'isFinite y \/
  is_minus_infinity x /\ is_not_nan y \/ is_not_nan x /\ is_plus_infinity y.

Axiom lt_special :
  forall (x:t) (y:t), lt x y ->
  t'isFinite x /\ t'isFinite y \/
  is_minus_infinity x /\ is_not_nan y /\ ~ is_minus_infinity y \/
  is_not_nan x /\ ~ is_plus_infinity x /\ is_plus_infinity y.

Axiom lt_lt_finite :
  forall (x:t) (y:t) (z:t), lt x y -> lt y z -> t'isFinite y.

Axiom positive_to_real :
  forall (x:t), t'isFinite x -> is_positive x -> (0%R <= (t'real x))%R.

Axiom to_real_positive :
  forall (x:t), t'isFinite x -> (0%R < (t'real x))%R -> is_positive x.

Axiom negative_to_real :
  forall (x:t), t'isFinite x -> is_negative x -> ((t'real x) <= 0%R)%R.

Axiom to_real_negative :
  forall (x:t), t'isFinite x -> ((t'real x) < 0%R)%R -> is_negative x.

Axiom negative_xor_positive :
  forall (x:t), ~ (is_positive x /\ is_negative x).

Axiom negative_or_positive :
  forall (x:t), is_not_nan x -> is_positive x \/ is_negative x.

Axiom diff_sign_trans :
  forall (x:t) (y:t) (z:t), diff_sign x y /\ diff_sign y z -> same_sign x z.

Axiom diff_sign_product :
  forall (x:t) (y:t),
  t'isFinite x /\ t'isFinite y /\ (((t'real x) * (t'real y))%R < 0%R)%R ->
  diff_sign x y.

Axiom same_sign_product :
  forall (x:t) (y:t), t'isFinite x /\ t'isFinite y /\ same_sign x y ->
  (0%R <= ((t'real x) * (t'real y))%R)%R.

(* Why3 assumption *)
Definition product_sign (z:t) (x:t) (y:t) : Prop :=
  (same_sign x y -> is_positive z) /\ (diff_sign x y -> is_negative z).

(* Why3 assumption *)
Definition overflow_value (m:mode) (x:t) : Prop :=
  match m with
  | RTN =>
      (is_positive x ->
       t'isFinite x /\
       ((t'real x) = (33554430 * 10141204801825835211973625643008)%R)) /\
      (~ is_positive x -> is_infinite x)
  | RTP =>
      (is_positive x -> is_infinite x) /\
      (~ is_positive x ->
       t'isFinite x /\
       ((t'real x) = (-(33554430 * 10141204801825835211973625643008)%R)%R))
  | RTZ =>
      (is_positive x ->
       t'isFinite x /\
       ((t'real x) = (33554430 * 10141204801825835211973625643008)%R)) /\
      (~ is_positive x ->
       t'isFinite x /\
       ((t'real x) = (-(33554430 * 10141204801825835211973625643008)%R)%R))
  | RNA|RNE => is_infinite x
  end.

(* Why3 assumption *)
Definition sign_zero_result (m:mode) (x:t) : Prop :=
  is_zero x -> match m with
               | RTN => is_negative x
               | _ => is_positive x
               end.

Axiom add_finite :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> t'isFinite y ->
  no_overflow m ((t'real x) + (t'real y))%R ->
  t'isFinite (add m x y) /\
  ((t'real (add m x y)) = (round m ((t'real x) + (t'real y))%R)).

Axiom add_finite_rev :
  forall (m:mode) (x:t) (y:t), t'isFinite (add m x y) ->
  t'isFinite x /\ t'isFinite y.

Axiom add_finite_rev_n :
  forall (m:mode) (x:t) (y:t), to_nearest m -> t'isFinite (add m x y) ->
  no_overflow m ((t'real x) + (t'real y))%R /\
  ((t'real (add m x y)) = (round m ((t'real x) + (t'real y))%R)).

Axiom sub_finite :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> t'isFinite y ->
  no_overflow m ((t'real x) - (t'real y))%R ->
  t'isFinite (sub m x y) /\
  ((t'real (sub m x y)) = (round m ((t'real x) - (t'real y))%R)).

Axiom sub_finite_rev :
  forall (m:mode) (x:t) (y:t), t'isFinite (sub m x y) ->
  t'isFinite x /\ t'isFinite y.

Axiom sub_finite_rev_n :
  forall (m:mode) (x:t) (y:t), to_nearest m -> t'isFinite (sub m x y) ->
  no_overflow m ((t'real x) - (t'real y))%R /\
  ((t'real (sub m x y)) = (round m ((t'real x) - (t'real y))%R)).

Axiom mul_finite :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> t'isFinite y ->
  no_overflow m ((t'real x) * (t'real y))%R ->
  t'isFinite (mul m x y) /\
  ((t'real (mul m x y)) = (round m ((t'real x) * (t'real y))%R)).

Axiom mul_finite_rev :
  forall (m:mode) (x:t) (y:t), t'isFinite (mul m x y) ->
  t'isFinite x /\ t'isFinite y.

Axiom mul_finite_rev_n :
  forall (m:mode) (x:t) (y:t), to_nearest m -> t'isFinite (mul m x y) ->
  no_overflow m ((t'real x) * (t'real y))%R /\
  ((t'real (mul m x y)) = (round m ((t'real x) * (t'real y))%R)).

Axiom div_finite :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> t'isFinite y -> ~ is_zero y ->
  no_overflow m ((t'real x) / (t'real y))%R ->
  t'isFinite (div m x y) /\
  ((t'real (div m x y)) = (round m ((t'real x) / (t'real y))%R)).

Axiom div_finite_rev :
  forall (m:mode) (x:t) (y:t), t'isFinite (div m x y) ->
  t'isFinite x /\ t'isFinite y /\ ~ is_zero y \/
  t'isFinite x /\ is_infinite y /\ ((t'real (div m x y)) = 0%R).

Axiom div_finite_rev_n :
  forall (m:mode) (x:t) (y:t), to_nearest m -> t'isFinite (div m x y) ->
  t'isFinite y ->
  no_overflow m ((t'real x) / (t'real y))%R /\
  ((t'real (div m x y)) = (round m ((t'real x) / (t'real y))%R)).

Axiom neg_finite :
  forall (x:t), t'isFinite x ->
  t'isFinite (neg x) /\ ((t'real (neg x)) = (-(t'real x))%R).

Axiom neg_finite_rev :
  forall (x:t), t'isFinite (neg x) ->
  t'isFinite x /\ ((t'real (neg x)) = (-(t'real x))%R).

Axiom abs_finite :
  forall (x:t), t'isFinite x ->
  t'isFinite (abs x) /\
  ((t'real (abs x)) = (Reals.Rbasic_fun.Rabs (t'real x))) /\
  is_positive (abs x).

Axiom abs_finite_rev :
  forall (x:t), t'isFinite (abs x) ->
  t'isFinite x /\ ((t'real (abs x)) = (Reals.Rbasic_fun.Rabs (t'real x))).

Axiom abs_universal : forall (x:t), ~ is_negative (abs x).

Axiom fma_finite :
  forall (m:mode) (x:t) (y:t) (z:t), t'isFinite x -> t'isFinite y ->
  t'isFinite z ->
  no_overflow m (((t'real x) * (t'real y))%R + (t'real z))%R ->
  t'isFinite (fma m x y z) /\
  ((t'real (fma m x y z)) =
   (round m (((t'real x) * (t'real y))%R + (t'real z))%R)).

Axiom fma_finite_rev :
  forall (m:mode) (x:t) (y:t) (z:t), t'isFinite (fma m x y z) ->
  t'isFinite x /\ t'isFinite y /\ t'isFinite z.

Axiom fma_finite_rev_n :
  forall (m:mode) (x:t) (y:t) (z:t), to_nearest m ->
  t'isFinite (fma m x y z) ->
  no_overflow m (((t'real x) * (t'real y))%R + (t'real z))%R /\
  ((t'real (fma m x y z)) =
   (round m (((t'real x) * (t'real y))%R + (t'real z))%R)).

Axiom sqrt_finite :
  forall (m:mode) (x:t), t'isFinite x -> (0%R <= (t'real x))%R ->
  t'isFinite (sqrt m x) /\
  ((t'real (sqrt m x)) = (round m (Reals.R_sqrt.sqrt (t'real x)))).

Axiom sqrt_finite_rev :
  forall (m:mode) (x:t), t'isFinite (sqrt m x) ->
  t'isFinite x /\
  (0%R <= (t'real x))%R /\
  ((t'real (sqrt m x)) = (round m (Reals.R_sqrt.sqrt (t'real x)))).

(* Why3 assumption *)
Definition same_sign_real (x:t) (r:Reals.Rdefinitions.R) : Prop :=
  is_positive x /\ (0%R < r)%R \/ is_negative x /\ (r < 0%R)%R.

Axiom add_special :
  forall (m:mode) (x:t) (y:t),
  let r := add m x y in
  (is_nan x \/ is_nan y -> is_nan r) /\
  (t'isFinite x /\ is_infinite y -> is_infinite r /\ same_sign r y) /\
  (is_infinite x /\ t'isFinite y -> is_infinite r /\ same_sign r x) /\
  (is_infinite x /\ is_infinite y /\ same_sign x y ->
   is_infinite r /\ same_sign r x) /\
  (is_infinite x /\ is_infinite y /\ diff_sign x y -> is_nan r) /\
  (t'isFinite x /\
   t'isFinite y /\ ~ no_overflow m ((t'real x) + (t'real y))%R ->
   same_sign_real r ((t'real x) + (t'real y))%R /\ overflow_value m r) /\
  (t'isFinite x /\ t'isFinite y ->
   (same_sign x y -> same_sign r x) /\
   (~ same_sign x y -> sign_zero_result m r)).

Axiom sub_special :
  forall (m:mode) (x:t) (y:t),
  let r := sub m x y in
  (is_nan x \/ is_nan y -> is_nan r) /\
  (t'isFinite x /\ is_infinite y -> is_infinite r /\ diff_sign r y) /\
  (is_infinite x /\ t'isFinite y -> is_infinite r /\ same_sign r x) /\
  (is_infinite x /\ is_infinite y /\ same_sign x y -> is_nan r) /\
  (is_infinite x /\ is_infinite y /\ diff_sign x y ->
   is_infinite r /\ same_sign r x) /\
  (t'isFinite x /\
   t'isFinite y /\ ~ no_overflow m ((t'real x) - (t'real y))%R ->
   same_sign_real r ((t'real x) - (t'real y))%R /\ overflow_value m r) /\
  (t'isFinite x /\ t'isFinite y ->
   (diff_sign x y -> same_sign r x) /\
   (~ diff_sign x y -> sign_zero_result m r)).

Axiom mul_special :
  forall (m:mode) (x:t) (y:t),
  let r := mul m x y in
  (is_nan x \/ is_nan y -> is_nan r) /\
  (is_zero x /\ is_infinite y -> is_nan r) /\
  (t'isFinite x /\ is_infinite y /\ ~ is_zero x -> is_infinite r) /\
  (is_infinite x /\ is_zero y -> is_nan r) /\
  (is_infinite x /\ t'isFinite y /\ ~ is_zero y -> is_infinite r) /\
  (is_infinite x /\ is_infinite y -> is_infinite r) /\
  (t'isFinite x /\
   t'isFinite y /\ ~ no_overflow m ((t'real x) * (t'real y))%R ->
   overflow_value m r) /\
  (~ is_nan r -> product_sign r x y).

Axiom div_special :
  forall (m:mode) (x:t) (y:t),
  let r := div m x y in
  (is_nan x \/ is_nan y -> is_nan r) /\
  (t'isFinite x /\ is_infinite y -> is_zero r) /\
  (is_infinite x /\ t'isFinite y -> is_infinite r) /\
  (is_infinite x /\ is_infinite y -> is_nan r) /\
  (t'isFinite x /\
   t'isFinite y /\ ~ is_zero y /\ ~ no_overflow m ((t'real x) / (t'real y))%R ->
   overflow_value m r) /\
  (t'isFinite x /\ is_zero y /\ ~ is_zero x -> is_infinite r) /\
  (is_zero x /\ is_zero y -> is_nan r) /\ (~ is_nan r -> product_sign r x y).

Axiom neg_special :
  forall (x:t),
  (is_nan x -> is_nan (neg x)) /\
  (is_infinite x -> is_infinite (neg x)) /\
  (~ is_nan x -> diff_sign x (neg x)).

Axiom abs_special :
  forall (x:t),
  (is_nan x -> is_nan (abs x)) /\
  (is_infinite x -> is_infinite (abs x)) /\
  (~ is_nan x -> is_positive (abs x)).

Axiom fma_special :
  forall (m:mode) (x:t) (y:t) (z:t),
  let r := fma m x y z in
  (is_nan x \/ is_nan y \/ is_nan z -> is_nan r) /\
  (is_zero x /\ is_infinite y -> is_nan r) /\
  (is_infinite x /\ is_zero y -> is_nan r) /\
  (t'isFinite x /\ ~ is_zero x /\ is_infinite y /\ t'isFinite z ->
   is_infinite r /\ product_sign r x y) /\
  (t'isFinite x /\ ~ is_zero x /\ is_infinite y /\ is_infinite z ->
   (product_sign z x y -> is_infinite r /\ same_sign r z) /\
   (~ product_sign z x y -> is_nan r)) /\
  (is_infinite x /\ t'isFinite y /\ ~ is_zero y /\ t'isFinite z ->
   is_infinite r /\ product_sign r x y) /\
  (is_infinite x /\ t'isFinite y /\ ~ is_zero y /\ is_infinite z ->
   (product_sign z x y -> is_infinite r /\ same_sign r z) /\
   (~ product_sign z x y -> is_nan r)) /\
  (is_infinite x /\ is_infinite y /\ t'isFinite z ->
   is_infinite r /\ product_sign r x y) /\
  (t'isFinite x /\ t'isFinite y /\ is_infinite z ->
   is_infinite r /\ same_sign r z) /\
  (is_infinite x /\ is_infinite y /\ is_infinite z ->
   (product_sign z x y -> is_infinite r /\ same_sign r z) /\
   (~ product_sign z x y -> is_nan r)) /\
  (t'isFinite x /\
   t'isFinite y /\
   t'isFinite z /\
   ~ no_overflow m (((t'real x) * (t'real y))%R + (t'real z))%R ->
   same_sign_real r (((t'real x) * (t'real y))%R + (t'real z))%R /\
   overflow_value m r) /\
  (t'isFinite x /\ t'isFinite y /\ t'isFinite z ->
   (product_sign z x y -> same_sign r z) /\
   (~ product_sign z x y ->
    ((((t'real x) * (t'real y))%R + (t'real z))%R = 0%R) ->
    ((m = RTN) -> is_negative r) /\ (~ (m = RTN) -> is_positive r))).

Axiom sqrt_special :
  forall (m:mode) (x:t),
  let r := sqrt m x in
  (is_nan x -> is_nan r) /\
  (is_plus_infinity x -> is_plus_infinity r) /\
  (is_minus_infinity x -> is_nan r) /\
  (t'isFinite x /\ ((t'real x) < 0%R)%R -> is_nan r) /\
  (is_zero x -> same_sign r x) /\
  (t'isFinite x /\ (0%R < (t'real x))%R -> is_positive r).

Axiom of_int_add_exact :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range i -> in_safe_int_range j ->
  in_safe_int_range (i + j)%Z ->
  eq (of_int m (i + j)%Z) (add n (of_int m i) (of_int m j)).

Axiom of_int_sub_exact :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range i -> in_safe_int_range j ->
  in_safe_int_range (i - j)%Z ->
  eq (of_int m (i - j)%Z) (sub n (of_int m i) (of_int m j)).

Axiom of_int_mul_exact :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range i -> in_safe_int_range j ->
  in_safe_int_range (i * j)%Z ->
  eq (of_int m (i * j)%Z) (mul n (of_int m i) (of_int m j)).

Axiom Min_r : forall (x:t) (y:t), le y x -> eq (min x y) y.

Axiom Min_l : forall (x:t) (y:t), le x y -> eq (min x y) x.

Axiom Max_r : forall (x:t) (y:t), le y x -> eq (max x y) x.

Axiom Max_l : forall (x:t) (y:t), le x y -> eq (max x y) y.

Parameter is_int: t -> Prop.

Axiom zeroF_is_int : is_int zeroF.

Axiom of_int_is_int :
  forall (m:mode) (x:Numbers.BinNums.Z), in_int_range x ->
  is_int (of_int m x).

Axiom big_float_is_int :
  forall (m:mode) (i:t), t'isFinite i ->
  le i (neg (of_int m 16777216%Z)) \/ le (of_int m 16777216%Z) i -> is_int i.

Axiom roundToIntegral_is_int :
  forall (m:mode) (x:t), t'isFinite x -> is_int (roundToIntegral m x).

Axiom eq_is_int : forall (x:t) (y:t), eq x y -> is_int x -> is_int y.

Axiom add_int :
  forall (x:t) (y:t) (m:mode), is_int x -> is_int y ->
  t'isFinite (add m x y) -> is_int (add m x y).

Axiom sub_int :
  forall (x:t) (y:t) (m:mode), is_int x -> is_int y ->
  t'isFinite (sub m x y) -> is_int (sub m x y).

Axiom mul_int :
  forall (x:t) (y:t) (m:mode), is_int x -> is_int y ->
  t'isFinite (mul m x y) -> is_int (mul m x y).

Axiom fma_int :
  forall (x:t) (y:t) (z:t) (m:mode), is_int x -> is_int y -> is_int z ->
  t'isFinite (fma m x y z) -> is_int (fma m x y z).

Axiom neg_int : forall (x:t), is_int x -> is_int (neg x).

Axiom abs_int : forall (x:t), is_int x -> is_int (abs x).

Axiom is_int_of_int :
  forall (x:t) (m:mode) (m':mode), is_int x -> eq x (of_int m' (to_int m x)).

Axiom is_int_to_int :
  forall (m:mode) (x:t), is_int x -> in_int_range (to_int m x).

Axiom is_int_is_finite : forall (x:t), is_int x -> t'isFinite x.

Axiom int_to_real :
  forall (m:mode) (x:t), is_int x ->
  ((t'real x) = (BuiltIn.IZR (to_int m x))).

Axiom truncate_int :
  forall (m:mode) (i:t), is_int i -> eq (roundToIntegral m i) i.

Axiom truncate_neg :
  forall (x:t), t'isFinite x -> is_negative x ->
  ((roundToIntegral RTZ x) = (roundToIntegral RTP x)).

Axiom truncate_pos :
  forall (x:t), t'isFinite x -> is_positive x ->
  ((roundToIntegral RTZ x) = (roundToIntegral RTN x)).

Axiom ceil_le : forall (x:t), t'isFinite x -> le x (roundToIntegral RTP x).

Axiom ceil_lest :
  forall (x:t) (y:t), le x y /\ is_int y -> le (roundToIntegral RTP x) y.

Axiom ceil_to_real :
  forall (x:t), t'isFinite x ->
  ((t'real (roundToIntegral RTP x)) = (BuiltIn.IZR (ceil (t'real x)))).

Axiom ceil_to_int :
  forall (m:mode) (x:t), t'isFinite x ->
  ((to_int m (roundToIntegral RTP x)) = (ceil (t'real x))).

Axiom floor_le : forall (x:t), t'isFinite x -> le (roundToIntegral RTN x) x.

Axiom floor_lest :
  forall (x:t) (y:t), le y x /\ is_int y -> le y (roundToIntegral RTN x).

Axiom floor_to_real :
  forall (x:t), t'isFinite x ->
  ((t'real (roundToIntegral RTN x)) = (BuiltIn.IZR (floor (t'real x)))).

Axiom floor_to_int :
  forall (m:mode) (x:t), t'isFinite x ->
  ((to_int m (roundToIntegral RTN x)) = (floor (t'real x))).

Axiom RNA_down :
  forall (x:t),
  lt (sub RNE x (roundToIntegral RTN x)) (sub RNE (roundToIntegral RTP x) x) ->
  ((roundToIntegral RNA x) = (roundToIntegral RTN x)).

Axiom RNA_up :
  forall (x:t),
  lt (sub RNE (roundToIntegral RTP x) x) (sub RNE x (roundToIntegral RTN x)) ->
  ((roundToIntegral RNA x) = (roundToIntegral RTP x)).

Axiom RNA_down_tie :
  forall (x:t),
  eq (sub RNE x (roundToIntegral RTN x)) (sub RNE (roundToIntegral RTP x) x) ->
  is_negative x -> ((roundToIntegral RNA x) = (roundToIntegral RTN x)).

Axiom RNA_up_tie :
  forall (x:t),
  eq (sub RNE (roundToIntegral RTP x) x) (sub RNE x (roundToIntegral RTN x)) ->
  is_positive x -> ((roundToIntegral RNA x) = (roundToIntegral RTP x)).

Axiom to_int_roundToIntegral :
  forall (m:mode) (x:t), ((to_int m x) = (to_int m (roundToIntegral m x))).

Axiom to_int_monotonic :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> t'isFinite y -> le x y ->
  ((to_int m x) <= (to_int m y))%Z.

Axiom to_int_of_int :
  forall (m:mode) (i:Numbers.BinNums.Z), in_safe_int_range i ->
  ((to_int m (of_int m i)) = i).

Axiom eq_to_int :
  forall (m:mode) (x:t) (y:t), t'isFinite x -> eq x y ->
  ((to_int m x) = (to_int m y)).

Axiom neg_to_int :
  forall (m:mode) (x:t), is_int x -> ((to_int m (neg x)) = (-(to_int m x))%Z).

Axiom roundToIntegral_is_finite :
  forall (m:mode) (x:t), t'isFinite x -> t'isFinite (roundToIntegral m x).

Axiom round_bound_ne :
  forall (x:Reals.Rdefinitions.R), no_overflow RNE x ->
  (((x - ((1 / 16777216)%R * (Reals.Rbasic_fun.Rabs x))%R)%R -
    (1 / 1427247692705959881058285969449495136382746624)%R)%R
   <= (round RNE x))%R /\
  ((round RNE x) <=
   ((x + ((1 / 16777216)%R * (Reals.Rbasic_fun.Rabs x))%R)%R +
    (1 / 1427247692705959881058285969449495136382746624)%R)%R)%R.

Axiom round_bound :
  forall (m:mode) (x:Reals.Rdefinitions.R), no_overflow m x ->
  (((x - ((1 / 8388608)%R * (Reals.Rbasic_fun.Rabs x))%R)%R -
    (1 / 713623846352979940529142984724747568191373312)%R)%R
   <= (round m x))%R /\
  ((round m x) <=
   ((x + ((1 / 8388608)%R * (Reals.Rbasic_fun.Rabs x))%R)%R +
    (1 / 713623846352979940529142984724747568191373312)%R)%R)%R.

Axiom t1 : Type.
Parameter t1_WhyType : WhyType t1.
Existing Instance t1_WhyType.

Parameter t'real1: t1 -> Reals.Rdefinitions.R.

Parameter t'isFinite1: t1 -> Prop.

Axiom t'axiom1 :
  forall (x:t1), t'isFinite1 x ->
  ((-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368%R)%R
   <= (t'real1 x))%R /\
  ((t'real1 x) <=
   179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368%R)%R.

Parameter zeroF1: t1.

Parameter add1: mode -> t1 -> t1 -> t1.

Parameter sub1: mode -> t1 -> t1 -> t1.

Parameter mul1: mode -> t1 -> t1 -> t1.

Parameter div1: mode -> t1 -> t1 -> t1.

Parameter abs1: t1 -> t1.

Parameter neg1: t1 -> t1.

Parameter fma1: mode -> t1 -> t1 -> t1 -> t1.

Parameter sqrt1: mode -> t1 -> t1.

Parameter roundToIntegral1: mode -> t1 -> t1.

Parameter min1: t1 -> t1 -> t1.

Parameter max1: t1 -> t1 -> t1.

Parameter le1: t1 -> t1 -> Prop.

Parameter lt1: t1 -> t1 -> Prop.

Parameter eq1: t1 -> t1 -> Prop.

Parameter is_normal1: t1 -> Prop.

Parameter is_subnormal1: t1 -> Prop.

Parameter is_zero1: t1 -> Prop.

Parameter is_infinite1: t1 -> Prop.

Parameter is_nan1: t1 -> Prop.

Parameter is_positive1: t1 -> Prop.

Parameter is_negative1: t1 -> Prop.

(* Why3 assumption *)
Definition is_plus_infinity1 (x:t1) : Prop :=
  is_infinite1 x /\ is_positive1 x.

(* Why3 assumption *)
Definition is_minus_infinity1 (x:t1) : Prop :=
  is_infinite1 x /\ is_negative1 x.

(* Why3 assumption *)
Definition is_plus_zero1 (x:t1) : Prop := is_zero1 x /\ is_positive1 x.

(* Why3 assumption *)
Definition is_minus_zero1 (x:t1) : Prop := is_zero1 x /\ is_negative1 x.

(* Why3 assumption *)
Definition is_not_nan2 (x:t1) : Prop := t'isFinite1 x \/ is_infinite1 x.

Axiom is_not_nan3 : forall (x:t1), is_not_nan2 x <-> ~ is_nan1 x.

Axiom is_not_finite1 :
  forall (x:t1), ~ t'isFinite1 x <-> is_infinite1 x \/ is_nan1 x.

Axiom zeroF_is_positive1 : is_positive1 zeroF1.

Axiom zeroF_is_zero1 : is_zero1 zeroF1.

Axiom zero_to_real1 :
  forall (x:t1), is_zero1 x <-> t'isFinite1 x /\ ((t'real1 x) = 0%R).

Parameter of_int1: mode -> Numbers.BinNums.Z -> t1.

Parameter to_int1: mode -> t1 -> Numbers.BinNums.Z.

Axiom zero_of_int1 : forall (m:mode), (zeroF1 = (of_int1 m 0%Z)).

Parameter round1: mode -> Reals.Rdefinitions.R -> Reals.Rdefinitions.R.

Parameter max_int1: Numbers.BinNums.Z.

Axiom max_real_int1 :
  ((9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R
   = (BuiltIn.IZR max_int1)).

(* Why3 assumption *)
Definition in_range1 (x:Reals.Rdefinitions.R) : Prop :=
  ((-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R
   <= x)%R /\
  (x <=
   (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R.

(* Why3 assumption *)
Definition in_int_range1 (i:Numbers.BinNums.Z) : Prop :=
  ((-max_int1)%Z <= i)%Z /\ (i <= max_int1)%Z.

Axiom is_finite1 : forall (x:t1), t'isFinite1 x -> in_range1 (t'real1 x).

(* Why3 assumption *)
Definition no_overflow1 (m:mode) (x:Reals.Rdefinitions.R) : Prop :=
  in_range1 (round1 m x).

Axiom Bounded_real_no_overflow1 :
  forall (m:mode) (x:Reals.Rdefinitions.R), in_range1 x -> no_overflow1 m x.

Axiom Round_monotonic1 :
  forall (m:mode) (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  (x <= y)%R -> ((round1 m x) <= (round1 m y))%R.

Axiom Round_idempotent1 :
  forall (m1:mode) (m2:mode) (x:Reals.Rdefinitions.R),
  ((round1 m1 (round1 m2 x)) = (round1 m2 x)).

Axiom Round_to_real1 :
  forall (m:mode) (x:t1), t'isFinite1 x ->
  ((round1 m (t'real1 x)) = (t'real1 x)).

Axiom Round_down_le1 :
  forall (x:Reals.Rdefinitions.R), ((round1 RTN x) <= x)%R.

Axiom Round_up_ge1 :
  forall (x:Reals.Rdefinitions.R), (x <= (round1 RTP x))%R.

Axiom Round_down_neg1 :
  forall (x:Reals.Rdefinitions.R),
  ((round1 RTN (-x)%R) = (-(round1 RTP x))%R).

Axiom Round_up_neg1 :
  forall (x:Reals.Rdefinitions.R),
  ((round1 RTP (-x)%R) = (-(round1 RTN x))%R).

(* Why3 assumption *)
Definition in_safe_int_range1 (i:Numbers.BinNums.Z) : Prop :=
  ((-9007199254740992%Z)%Z <= i)%Z /\ (i <= 9007199254740992%Z)%Z.

Axiom Exact_rounding_for_integers1 :
  forall (m:mode) (i:Numbers.BinNums.Z), in_safe_int_range1 i ->
  ((round1 m (BuiltIn.IZR i)) = (BuiltIn.IZR i)).

(* Why3 assumption *)
Definition same_sign1 (x:t1) (y:t1) : Prop :=
  is_positive1 x /\ is_positive1 y \/ is_negative1 x /\ is_negative1 y.

(* Why3 assumption *)
Definition diff_sign1 (x:t1) (y:t1) : Prop :=
  is_positive1 x /\ is_negative1 y \/ is_negative1 x /\ is_positive1 y.

Axiom feq_eq1 :
  forall (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y -> ~ is_zero1 x ->
  eq1 x y -> (x = y).

Axiom eq_feq1 :
  forall (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y -> (x = y) -> eq1 x y.

Axiom eq_refl1 : forall (x:t1), t'isFinite1 x -> eq1 x x.

Axiom eq_sym1 : forall (x:t1) (y:t1), eq1 x y -> eq1 y x.

Axiom eq_trans1 : forall (x:t1) (y:t1) (z:t1), eq1 x y -> eq1 y z -> eq1 x z.

Axiom eq_zero1 : eq1 zeroF1 (neg1 zeroF1).

Axiom eq_to_real_finite1 :
  forall (x:t1) (y:t1), t'isFinite1 x /\ t'isFinite1 y ->
  eq1 x y <-> ((t'real1 x) = (t'real1 y)).

Axiom eq_special1 :
  forall (x:t1) (y:t1), eq1 x y ->
  is_not_nan2 x /\
  is_not_nan2 y /\
  (t'isFinite1 x /\ t'isFinite1 y \/
   is_infinite1 x /\ is_infinite1 y /\ same_sign1 x y).

Axiom lt_finite1 :
  forall (x:t1) (y:t1), t'isFinite1 x /\ t'isFinite1 y ->
  lt1 x y <-> ((t'real1 x) < (t'real1 y))%R.

Axiom le_finite1 :
  forall (x:t1) (y:t1), t'isFinite1 x /\ t'isFinite1 y ->
  le1 x y <-> ((t'real1 x) <= (t'real1 y))%R.

Axiom le_lt_trans1 :
  forall (x:t1) (y:t1) (z:t1), le1 x y /\ lt1 y z -> lt1 x z.

Axiom lt_le_trans1 :
  forall (x:t1) (y:t1) (z:t1), lt1 x y /\ le1 y z -> lt1 x z.

Axiom le_ge_asym1 : forall (x:t1) (y:t1), le1 x y /\ le1 y x -> eq1 x y.

Axiom not_lt_ge1 :
  forall (x:t1) (y:t1), ~ lt1 x y /\ is_not_nan2 x /\ is_not_nan2 y ->
  le1 y x.

Axiom not_gt_le1 :
  forall (x:t1) (y:t1), ~ lt1 y x /\ is_not_nan2 x /\ is_not_nan2 y ->
  le1 x y.

Axiom le_special1 :
  forall (x:t1) (y:t1), le1 x y ->
  t'isFinite1 x /\ t'isFinite1 y \/
  is_minus_infinity1 x /\ is_not_nan2 y \/
  is_not_nan2 x /\ is_plus_infinity1 y.

Axiom lt_special1 :
  forall (x:t1) (y:t1), lt1 x y ->
  t'isFinite1 x /\ t'isFinite1 y \/
  is_minus_infinity1 x /\ is_not_nan2 y /\ ~ is_minus_infinity1 y \/
  is_not_nan2 x /\ ~ is_plus_infinity1 x /\ is_plus_infinity1 y.

Axiom lt_lt_finite1 :
  forall (x:t1) (y:t1) (z:t1), lt1 x y -> lt1 y z -> t'isFinite1 y.

Axiom positive_to_real1 :
  forall (x:t1), t'isFinite1 x -> is_positive1 x -> (0%R <= (t'real1 x))%R.

Axiom to_real_positive1 :
  forall (x:t1), t'isFinite1 x -> (0%R < (t'real1 x))%R -> is_positive1 x.

Axiom negative_to_real1 :
  forall (x:t1), t'isFinite1 x -> is_negative1 x -> ((t'real1 x) <= 0%R)%R.

Axiom to_real_negative1 :
  forall (x:t1), t'isFinite1 x -> ((t'real1 x) < 0%R)%R -> is_negative1 x.

Axiom negative_xor_positive1 :
  forall (x:t1), ~ (is_positive1 x /\ is_negative1 x).

Axiom negative_or_positive1 :
  forall (x:t1), is_not_nan2 x -> is_positive1 x \/ is_negative1 x.

Axiom diff_sign_trans1 :
  forall (x:t1) (y:t1) (z:t1), diff_sign1 x y /\ diff_sign1 y z ->
  same_sign1 x z.

Axiom diff_sign_product1 :
  forall (x:t1) (y:t1),
  t'isFinite1 x /\ t'isFinite1 y /\ (((t'real1 x) * (t'real1 y))%R < 0%R)%R ->
  diff_sign1 x y.

Axiom same_sign_product1 :
  forall (x:t1) (y:t1), t'isFinite1 x /\ t'isFinite1 y /\ same_sign1 x y ->
  (0%R <= ((t'real1 x) * (t'real1 y))%R)%R.

(* Why3 assumption *)
Definition product_sign1 (z:t1) (x:t1) (y:t1) : Prop :=
  (same_sign1 x y -> is_positive1 z) /\ (diff_sign1 x y -> is_negative1 z).

(* Why3 assumption *)
Definition overflow_value1 (m:mode) (x:t1) : Prop :=
  match m with
  | RTN =>
      (is_positive1 x ->
       t'isFinite1 x /\
       ((t'real1 x) =
        (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)) /\
      (~ is_positive1 x -> is_infinite1 x)
  | RTP =>
      (is_positive1 x -> is_infinite1 x) /\
      (~ is_positive1 x ->
       t'isFinite1 x /\
       ((t'real1 x) =
        (-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R))
  | RTZ =>
      (is_positive1 x ->
       t'isFinite1 x /\
       ((t'real1 x) =
        (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)) /\
      (~ is_positive1 x ->
       t'isFinite1 x /\
       ((t'real1 x) =
        (-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R))
  | RNA|RNE => is_infinite1 x
  end.

(* Why3 assumption *)
Definition sign_zero_result1 (m:mode) (x:t1) : Prop :=
  is_zero1 x -> match m with
                | RTN => is_negative1 x
                | _ => is_positive1 x
                end.

Axiom add_finite1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y ->
  no_overflow1 m ((t'real1 x) + (t'real1 y))%R ->
  t'isFinite1 (add1 m x y) /\
  ((t'real1 (add1 m x y)) = (round1 m ((t'real1 x) + (t'real1 y))%R)).

Axiom add_finite_rev1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 (add1 m x y) ->
  t'isFinite1 x /\ t'isFinite1 y.

Axiom add_finite_rev_n1 :
  forall (m:mode) (x:t1) (y:t1), to_nearest m -> t'isFinite1 (add1 m x y) ->
  no_overflow1 m ((t'real1 x) + (t'real1 y))%R /\
  ((t'real1 (add1 m x y)) = (round1 m ((t'real1 x) + (t'real1 y))%R)).

Axiom sub_finite1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y ->
  no_overflow1 m ((t'real1 x) - (t'real1 y))%R ->
  t'isFinite1 (sub1 m x y) /\
  ((t'real1 (sub1 m x y)) = (round1 m ((t'real1 x) - (t'real1 y))%R)).

Axiom sub_finite_rev1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 (sub1 m x y) ->
  t'isFinite1 x /\ t'isFinite1 y.

Axiom sub_finite_rev_n1 :
  forall (m:mode) (x:t1) (y:t1), to_nearest m -> t'isFinite1 (sub1 m x y) ->
  no_overflow1 m ((t'real1 x) - (t'real1 y))%R /\
  ((t'real1 (sub1 m x y)) = (round1 m ((t'real1 x) - (t'real1 y))%R)).

Axiom mul_finite1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y ->
  no_overflow1 m ((t'real1 x) * (t'real1 y))%R ->
  t'isFinite1 (mul1 m x y) /\
  ((t'real1 (mul1 m x y)) = (round1 m ((t'real1 x) * (t'real1 y))%R)).

Axiom mul_finite_rev1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 (mul1 m x y) ->
  t'isFinite1 x /\ t'isFinite1 y.

Axiom mul_finite_rev_n1 :
  forall (m:mode) (x:t1) (y:t1), to_nearest m -> t'isFinite1 (mul1 m x y) ->
  no_overflow1 m ((t'real1 x) * (t'real1 y))%R /\
  ((t'real1 (mul1 m x y)) = (round1 m ((t'real1 x) * (t'real1 y))%R)).

Axiom div_finite1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y ->
  ~ is_zero1 y -> no_overflow1 m ((t'real1 x) / (t'real1 y))%R ->
  t'isFinite1 (div1 m x y) /\
  ((t'real1 (div1 m x y)) = (round1 m ((t'real1 x) / (t'real1 y))%R)).

Axiom div_finite_rev1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 (div1 m x y) ->
  t'isFinite1 x /\ t'isFinite1 y /\ ~ is_zero1 y \/
  t'isFinite1 x /\ is_infinite1 y /\ ((t'real1 (div1 m x y)) = 0%R).

Axiom div_finite_rev_n1 :
  forall (m:mode) (x:t1) (y:t1), to_nearest m -> t'isFinite1 (div1 m x y) ->
  t'isFinite1 y ->
  no_overflow1 m ((t'real1 x) / (t'real1 y))%R /\
  ((t'real1 (div1 m x y)) = (round1 m ((t'real1 x) / (t'real1 y))%R)).

Axiom neg_finite1 :
  forall (x:t1), t'isFinite1 x ->
  t'isFinite1 (neg1 x) /\ ((t'real1 (neg1 x)) = (-(t'real1 x))%R).

Axiom neg_finite_rev1 :
  forall (x:t1), t'isFinite1 (neg1 x) ->
  t'isFinite1 x /\ ((t'real1 (neg1 x)) = (-(t'real1 x))%R).

Axiom abs_finite1 :
  forall (x:t1), t'isFinite1 x ->
  t'isFinite1 (abs1 x) /\
  ((t'real1 (abs1 x)) = (Reals.Rbasic_fun.Rabs (t'real1 x))) /\
  is_positive1 (abs1 x).

Axiom abs_finite_rev1 :
  forall (x:t1), t'isFinite1 (abs1 x) ->
  t'isFinite1 x /\ ((t'real1 (abs1 x)) = (Reals.Rbasic_fun.Rabs (t'real1 x))).

Axiom abs_universal1 : forall (x:t1), ~ is_negative1 (abs1 x).

Axiom fma_finite1 :
  forall (m:mode) (x:t1) (y:t1) (z:t1), t'isFinite1 x -> t'isFinite1 y ->
  t'isFinite1 z ->
  no_overflow1 m (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R ->
  t'isFinite1 (fma1 m x y z) /\
  ((t'real1 (fma1 m x y z)) =
   (round1 m (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R)).

Axiom fma_finite_rev1 :
  forall (m:mode) (x:t1) (y:t1) (z:t1), t'isFinite1 (fma1 m x y z) ->
  t'isFinite1 x /\ t'isFinite1 y /\ t'isFinite1 z.

Axiom fma_finite_rev_n1 :
  forall (m:mode) (x:t1) (y:t1) (z:t1), to_nearest m ->
  t'isFinite1 (fma1 m x y z) ->
  no_overflow1 m (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R /\
  ((t'real1 (fma1 m x y z)) =
   (round1 m (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R)).

Axiom sqrt_finite1 :
  forall (m:mode) (x:t1), t'isFinite1 x -> (0%R <= (t'real1 x))%R ->
  t'isFinite1 (sqrt1 m x) /\
  ((t'real1 (sqrt1 m x)) = (round1 m (Reals.R_sqrt.sqrt (t'real1 x)))).

Axiom sqrt_finite_rev1 :
  forall (m:mode) (x:t1), t'isFinite1 (sqrt1 m x) ->
  t'isFinite1 x /\
  (0%R <= (t'real1 x))%R /\
  ((t'real1 (sqrt1 m x)) = (round1 m (Reals.R_sqrt.sqrt (t'real1 x)))).

(* Why3 assumption *)
Definition same_sign_real1 (x:t1) (r:Reals.Rdefinitions.R) : Prop :=
  is_positive1 x /\ (0%R < r)%R \/ is_negative1 x /\ (r < 0%R)%R.

Axiom add_special1 :
  forall (m:mode) (x:t1) (y:t1),
  let r := add1 m x y in
  (is_nan1 x \/ is_nan1 y -> is_nan1 r) /\
  (t'isFinite1 x /\ is_infinite1 y -> is_infinite1 r /\ same_sign1 r y) /\
  (is_infinite1 x /\ t'isFinite1 y -> is_infinite1 r /\ same_sign1 r x) /\
  (is_infinite1 x /\ is_infinite1 y /\ same_sign1 x y ->
   is_infinite1 r /\ same_sign1 r x) /\
  (is_infinite1 x /\ is_infinite1 y /\ diff_sign1 x y -> is_nan1 r) /\
  (t'isFinite1 x /\
   t'isFinite1 y /\ ~ no_overflow1 m ((t'real1 x) + (t'real1 y))%R ->
   same_sign_real1 r ((t'real1 x) + (t'real1 y))%R /\ overflow_value1 m r) /\
  (t'isFinite1 x /\ t'isFinite1 y ->
   (same_sign1 x y -> same_sign1 r x) /\
   (~ same_sign1 x y -> sign_zero_result1 m r)).

Axiom sub_special1 :
  forall (m:mode) (x:t1) (y:t1),
  let r := sub1 m x y in
  (is_nan1 x \/ is_nan1 y -> is_nan1 r) /\
  (t'isFinite1 x /\ is_infinite1 y -> is_infinite1 r /\ diff_sign1 r y) /\
  (is_infinite1 x /\ t'isFinite1 y -> is_infinite1 r /\ same_sign1 r x) /\
  (is_infinite1 x /\ is_infinite1 y /\ same_sign1 x y -> is_nan1 r) /\
  (is_infinite1 x /\ is_infinite1 y /\ diff_sign1 x y ->
   is_infinite1 r /\ same_sign1 r x) /\
  (t'isFinite1 x /\
   t'isFinite1 y /\ ~ no_overflow1 m ((t'real1 x) - (t'real1 y))%R ->
   same_sign_real1 r ((t'real1 x) - (t'real1 y))%R /\ overflow_value1 m r) /\
  (t'isFinite1 x /\ t'isFinite1 y ->
   (diff_sign1 x y -> same_sign1 r x) /\
   (~ diff_sign1 x y -> sign_zero_result1 m r)).

Axiom mul_special1 :
  forall (m:mode) (x:t1) (y:t1),
  let r := mul1 m x y in
  (is_nan1 x \/ is_nan1 y -> is_nan1 r) /\
  (is_zero1 x /\ is_infinite1 y -> is_nan1 r) /\
  (t'isFinite1 x /\ is_infinite1 y /\ ~ is_zero1 x -> is_infinite1 r) /\
  (is_infinite1 x /\ is_zero1 y -> is_nan1 r) /\
  (is_infinite1 x /\ t'isFinite1 y /\ ~ is_zero1 y -> is_infinite1 r) /\
  (is_infinite1 x /\ is_infinite1 y -> is_infinite1 r) /\
  (t'isFinite1 x /\
   t'isFinite1 y /\ ~ no_overflow1 m ((t'real1 x) * (t'real1 y))%R ->
   overflow_value1 m r) /\
  (~ is_nan1 r -> product_sign1 r x y).

Axiom div_special1 :
  forall (m:mode) (x:t1) (y:t1),
  let r := div1 m x y in
  (is_nan1 x \/ is_nan1 y -> is_nan1 r) /\
  (t'isFinite1 x /\ is_infinite1 y -> is_zero1 r) /\
  (is_infinite1 x /\ t'isFinite1 y -> is_infinite1 r) /\
  (is_infinite1 x /\ is_infinite1 y -> is_nan1 r) /\
  (t'isFinite1 x /\
   t'isFinite1 y /\
   ~ is_zero1 y /\ ~ no_overflow1 m ((t'real1 x) / (t'real1 y))%R ->
   overflow_value1 m r) /\
  (t'isFinite1 x /\ is_zero1 y /\ ~ is_zero1 x -> is_infinite1 r) /\
  (is_zero1 x /\ is_zero1 y -> is_nan1 r) /\
  (~ is_nan1 r -> product_sign1 r x y).

Axiom neg_special1 :
  forall (x:t1),
  (is_nan1 x -> is_nan1 (neg1 x)) /\
  (is_infinite1 x -> is_infinite1 (neg1 x)) /\
  (~ is_nan1 x -> diff_sign1 x (neg1 x)).

Axiom abs_special1 :
  forall (x:t1),
  (is_nan1 x -> is_nan1 (abs1 x)) /\
  (is_infinite1 x -> is_infinite1 (abs1 x)) /\
  (~ is_nan1 x -> is_positive1 (abs1 x)).

Axiom fma_special1 :
  forall (m:mode) (x:t1) (y:t1) (z:t1),
  let r := fma1 m x y z in
  (is_nan1 x \/ is_nan1 y \/ is_nan1 z -> is_nan1 r) /\
  (is_zero1 x /\ is_infinite1 y -> is_nan1 r) /\
  (is_infinite1 x /\ is_zero1 y -> is_nan1 r) /\
  (t'isFinite1 x /\ ~ is_zero1 x /\ is_infinite1 y /\ t'isFinite1 z ->
   is_infinite1 r /\ product_sign1 r x y) /\
  (t'isFinite1 x /\ ~ is_zero1 x /\ is_infinite1 y /\ is_infinite1 z ->
   (product_sign1 z x y -> is_infinite1 r /\ same_sign1 r z) /\
   (~ product_sign1 z x y -> is_nan1 r)) /\
  (is_infinite1 x /\ t'isFinite1 y /\ ~ is_zero1 y /\ t'isFinite1 z ->
   is_infinite1 r /\ product_sign1 r x y) /\
  (is_infinite1 x /\ t'isFinite1 y /\ ~ is_zero1 y /\ is_infinite1 z ->
   (product_sign1 z x y -> is_infinite1 r /\ same_sign1 r z) /\
   (~ product_sign1 z x y -> is_nan1 r)) /\
  (is_infinite1 x /\ is_infinite1 y /\ t'isFinite1 z ->
   is_infinite1 r /\ product_sign1 r x y) /\
  (t'isFinite1 x /\ t'isFinite1 y /\ is_infinite1 z ->
   is_infinite1 r /\ same_sign1 r z) /\
  (is_infinite1 x /\ is_infinite1 y /\ is_infinite1 z ->
   (product_sign1 z x y -> is_infinite1 r /\ same_sign1 r z) /\
   (~ product_sign1 z x y -> is_nan1 r)) /\
  (t'isFinite1 x /\
   t'isFinite1 y /\
   t'isFinite1 z /\
   ~ no_overflow1 m (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R ->
   same_sign_real1 r (((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R /\
   overflow_value1 m r) /\
  (t'isFinite1 x /\ t'isFinite1 y /\ t'isFinite1 z ->
   (product_sign1 z x y -> same_sign1 r z) /\
   (~ product_sign1 z x y ->
    ((((t'real1 x) * (t'real1 y))%R + (t'real1 z))%R = 0%R) ->
    ((m = RTN) -> is_negative1 r) /\ (~ (m = RTN) -> is_positive1 r))).

Axiom sqrt_special1 :
  forall (m:mode) (x:t1),
  let r := sqrt1 m x in
  (is_nan1 x -> is_nan1 r) /\
  (is_plus_infinity1 x -> is_plus_infinity1 r) /\
  (is_minus_infinity1 x -> is_nan1 r) /\
  (t'isFinite1 x /\ ((t'real1 x) < 0%R)%R -> is_nan1 r) /\
  (is_zero1 x -> same_sign1 r x) /\
  (t'isFinite1 x /\ (0%R < (t'real1 x))%R -> is_positive1 r).

Axiom of_int_add_exact1 :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range1 i -> in_safe_int_range1 j ->
  in_safe_int_range1 (i + j)%Z ->
  eq1 (of_int1 m (i + j)%Z) (add1 n (of_int1 m i) (of_int1 m j)).

Axiom of_int_sub_exact1 :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range1 i -> in_safe_int_range1 j ->
  in_safe_int_range1 (i - j)%Z ->
  eq1 (of_int1 m (i - j)%Z) (sub1 n (of_int1 m i) (of_int1 m j)).

Axiom of_int_mul_exact1 :
  forall (m:mode) (n:mode) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  in_safe_int_range1 i -> in_safe_int_range1 j ->
  in_safe_int_range1 (i * j)%Z ->
  eq1 (of_int1 m (i * j)%Z) (mul1 n (of_int1 m i) (of_int1 m j)).

Axiom Min_r1 : forall (x:t1) (y:t1), le1 y x -> eq1 (min1 x y) y.

Axiom Min_l1 : forall (x:t1) (y:t1), le1 x y -> eq1 (min1 x y) x.

Axiom Max_r1 : forall (x:t1) (y:t1), le1 y x -> eq1 (max1 x y) x.

Axiom Max_l1 : forall (x:t1) (y:t1), le1 x y -> eq1 (max1 x y) y.

Parameter is_int1: t1 -> Prop.

Axiom zeroF_is_int1 : is_int1 zeroF1.

Axiom of_int_is_int1 :
  forall (m:mode) (x:Numbers.BinNums.Z), in_int_range1 x ->
  is_int1 (of_int1 m x).

Axiom big_float_is_int1 :
  forall (m:mode) (i:t1), t'isFinite1 i ->
  le1 i (neg1 (of_int1 m 9007199254740992%Z)) \/
  le1 (of_int1 m 9007199254740992%Z) i -> is_int1 i.

Axiom roundToIntegral_is_int1 :
  forall (m:mode) (x:t1), t'isFinite1 x -> is_int1 (roundToIntegral1 m x).

Axiom eq_is_int1 : forall (x:t1) (y:t1), eq1 x y -> is_int1 x -> is_int1 y.

Axiom add_int1 :
  forall (x:t1) (y:t1) (m:mode), is_int1 x -> is_int1 y ->
  t'isFinite1 (add1 m x y) -> is_int1 (add1 m x y).

Axiom sub_int1 :
  forall (x:t1) (y:t1) (m:mode), is_int1 x -> is_int1 y ->
  t'isFinite1 (sub1 m x y) -> is_int1 (sub1 m x y).

Axiom mul_int1 :
  forall (x:t1) (y:t1) (m:mode), is_int1 x -> is_int1 y ->
  t'isFinite1 (mul1 m x y) -> is_int1 (mul1 m x y).

Axiom fma_int1 :
  forall (x:t1) (y:t1) (z:t1) (m:mode), is_int1 x -> is_int1 y ->
  is_int1 z -> t'isFinite1 (fma1 m x y z) -> is_int1 (fma1 m x y z).

Axiom neg_int1 : forall (x:t1), is_int1 x -> is_int1 (neg1 x).

Axiom abs_int1 : forall (x:t1), is_int1 x -> is_int1 (abs1 x).

Axiom is_int_of_int1 :
  forall (x:t1) (m:mode) (m':mode), is_int1 x ->
  eq1 x (of_int1 m' (to_int1 m x)).

Axiom is_int_to_int1 :
  forall (m:mode) (x:t1), is_int1 x -> in_int_range1 (to_int1 m x).

Axiom is_int_is_finite1 : forall (x:t1), is_int1 x -> t'isFinite1 x.

Axiom int_to_real1 :
  forall (m:mode) (x:t1), is_int1 x ->
  ((t'real1 x) = (BuiltIn.IZR (to_int1 m x))).

Axiom truncate_int1 :
  forall (m:mode) (i:t1), is_int1 i -> eq1 (roundToIntegral1 m i) i.

Axiom truncate_neg1 :
  forall (x:t1), t'isFinite1 x -> is_negative1 x ->
  ((roundToIntegral1 RTZ x) = (roundToIntegral1 RTP x)).

Axiom truncate_pos1 :
  forall (x:t1), t'isFinite1 x -> is_positive1 x ->
  ((roundToIntegral1 RTZ x) = (roundToIntegral1 RTN x)).

Axiom ceil_le1 :
  forall (x:t1), t'isFinite1 x -> le1 x (roundToIntegral1 RTP x).

Axiom ceil_lest1 :
  forall (x:t1) (y:t1), le1 x y /\ is_int1 y ->
  le1 (roundToIntegral1 RTP x) y.

Axiom ceil_to_real1 :
  forall (x:t1), t'isFinite1 x ->
  ((t'real1 (roundToIntegral1 RTP x)) = (BuiltIn.IZR (ceil (t'real1 x)))).

Axiom ceil_to_int1 :
  forall (m:mode) (x:t1), t'isFinite1 x ->
  ((to_int1 m (roundToIntegral1 RTP x)) = (ceil (t'real1 x))).

Axiom floor_le1 :
  forall (x:t1), t'isFinite1 x -> le1 (roundToIntegral1 RTN x) x.

Axiom floor_lest1 :
  forall (x:t1) (y:t1), le1 y x /\ is_int1 y ->
  le1 y (roundToIntegral1 RTN x).

Axiom floor_to_real1 :
  forall (x:t1), t'isFinite1 x ->
  ((t'real1 (roundToIntegral1 RTN x)) = (BuiltIn.IZR (floor (t'real1 x)))).

Axiom floor_to_int1 :
  forall (m:mode) (x:t1), t'isFinite1 x ->
  ((to_int1 m (roundToIntegral1 RTN x)) = (floor (t'real1 x))).

Axiom RNA_down1 :
  forall (x:t1),
  lt1 (sub1 RNE x (roundToIntegral1 RTN x))
  (sub1 RNE (roundToIntegral1 RTP x) x) ->
  ((roundToIntegral1 RNA x) = (roundToIntegral1 RTN x)).

Axiom RNA_up1 :
  forall (x:t1),
  lt1 (sub1 RNE (roundToIntegral1 RTP x) x)
  (sub1 RNE x (roundToIntegral1 RTN x)) ->
  ((roundToIntegral1 RNA x) = (roundToIntegral1 RTP x)).

Axiom RNA_down_tie1 :
  forall (x:t1),
  eq1 (sub1 RNE x (roundToIntegral1 RTN x))
  (sub1 RNE (roundToIntegral1 RTP x) x) -> is_negative1 x ->
  ((roundToIntegral1 RNA x) = (roundToIntegral1 RTN x)).

Axiom RNA_up_tie1 :
  forall (x:t1),
  eq1 (sub1 RNE (roundToIntegral1 RTP x) x)
  (sub1 RNE x (roundToIntegral1 RTN x)) -> is_positive1 x ->
  ((roundToIntegral1 RNA x) = (roundToIntegral1 RTP x)).

Axiom to_int_roundToIntegral1 :
  forall (m:mode) (x:t1),
  ((to_int1 m x) = (to_int1 m (roundToIntegral1 m x))).

Axiom to_int_monotonic1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> t'isFinite1 y -> le1 x y ->
  ((to_int1 m x) <= (to_int1 m y))%Z.

Axiom to_int_of_int1 :
  forall (m:mode) (i:Numbers.BinNums.Z), in_safe_int_range1 i ->
  ((to_int1 m (of_int1 m i)) = i).

Axiom eq_to_int1 :
  forall (m:mode) (x:t1) (y:t1), t'isFinite1 x -> eq1 x y ->
  ((to_int1 m x) = (to_int1 m y)).

Axiom neg_to_int1 :
  forall (m:mode) (x:t1), is_int1 x ->
  ((to_int1 m (neg1 x)) = (-(to_int1 m x))%Z).

Axiom roundToIntegral_is_finite1 :
  forall (m:mode) (x:t1), t'isFinite1 x -> t'isFinite1 (roundToIntegral1 m x).

Axiom round_bound_ne1 :
  forall (x:Reals.Rdefinitions.R), no_overflow1 RNE x ->
  (((x - ((1 / 9007199254740992)%R * (Reals.Rbasic_fun.Rabs x))%R)%R -
    (1 / 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568)%R)%R
   <= (round1 RNE x))%R /\
  ((round1 RNE x) <=
   ((x + ((1 / 9007199254740992)%R * (Reals.Rbasic_fun.Rabs x))%R)%R +
    (1 / 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568)%R)%R)%R.

Axiom round_bound1 :
  forall (m:mode) (x:Reals.Rdefinitions.R), no_overflow1 m x ->
  (((x - ((1 / 4503599627370496)%R * (Reals.Rbasic_fun.Rabs x))%R)%R -
    (1 / 202402253307310618352495346718917307049556649764142118356901358027430339567995346891960383701437124495187077864316811911389808737385793476867013399940738509921517424276566361364466907742093216341239767678472745068562007483424692698618103355649159556340810056512358769552333414615230502532186327508646006263307707741093494784)%R)%R
   <= (round1 m x))%R /\
  ((round1 m x) <=
   ((x + ((1 / 4503599627370496)%R * (Reals.Rbasic_fun.Rabs x))%R)%R +
    (1 / 202402253307310618352495346718917307049556649764142118356901358027430339567995346891960383701437124495187077864316811911389808737385793476867013399940738509921517424276566361364466907742093216341239767678472745068562007483424692698618103355649159556340810056512358769552333414615230502532186327508646006263307707741093494784)%R)%R)%R.

Parameter to_float64: mode -> t -> t1.

Parameter to_float32: mode -> t1 -> t.

Axiom round_double_single :
  forall (m1:mode) (m2:mode) (x:Reals.Rdefinitions.R),
  ((round1 m1 (round m2 x)) = (round m2 x)).

Axiom to_float64_exact :
  forall (m:mode) (x:t), t'isFinite x ->
  t'isFinite1 (to_float64 m x) /\ ((t'real1 (to_float64 m x)) = (t'real x)).

Axiom to_float32_conv :
  forall (m:mode) (x:t1), t'isFinite1 x -> no_overflow m (t'real1 x) ->
  t'isFinite (to_float32 m x) /\
  ((t'real (to_float32 m x)) = (round m (t'real1 x))).

(* Why3 assumption *)
Definition f32 := t.

(* Why3 assumption *)
Definition f64 := t1.

Parameter to_f32: Reals.Rdefinitions.R -> t.

Parameter to_f64: Reals.Rdefinitions.R -> t1.

Axiom to_float_is_finite_32 :
  forall (f:t), t'isFinite f -> eq (to_f32 (t'real f)) f.

Axiom to_f32_range_round :
  forall (x:Reals.Rdefinitions.R), in_range x ->
  ((t'real (to_f32 x)) = (round RNE x)).

Axiom to_f32_range_finite :
  forall (x:Reals.Rdefinitions.R), in_range x -> t'isFinite (to_f32 x).

Axiom to_f32_minus_infinity :
  forall (x:Reals.Rdefinitions.R),
  (x < (-(33554430 * 10141204801825835211973625643008)%R)%R)%R ->
  is_minus_infinity (to_f32 x).

Axiom to_f32_plus_infinity :
  forall (x:Reals.Rdefinitions.R),
  ((33554430 * 10141204801825835211973625643008)%R < x)%R ->
  is_plus_infinity (to_f32 x).

Axiom to_float_is_finite_64 :
  forall (f:t1), t'isFinite1 f -> eq1 (to_f64 (t'real1 f)) f.

Axiom to_f64_range_round :
  forall (x:Reals.Rdefinitions.R), in_range1 x ->
  ((t'real1 (to_f64 x)) = (round1 RNE x)).

Axiom to_f64_range_finite :
  forall (x:Reals.Rdefinitions.R), in_range1 x -> t'isFinite1 (to_f64 x).

Axiom to_f64_minus_infinity :
  forall (x:Reals.Rdefinitions.R),
  (x <
   (-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R)%R ->
  is_minus_infinity1 (to_f64 x).

Axiom to_f64_plus_infinity :
  forall (x:Reals.Rdefinitions.R),
  ((9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R
   < x)%R ->
  is_plus_infinity1 (to_f64 x).

(* Why3 assumption *)
Definition round_float (m:mode) (r:Reals.Rdefinitions.R) : t :=
  to_f32 (round m r).

(* Why3 assumption *)
Definition round_double (m:mode) (r:Reals.Rdefinitions.R) : t1 :=
  to_f64 (round1 m r).

Axiom is_zero_to_f32_zero : is_zero (to_f32 0%R).

Axiom is_zero_to_f64_zero : is_zero1 (to_f64 0%R).

Axiom real_0_is_zero_f32 : forall (f:t), (0%R = (t'real f)) -> is_zero f.

Axiom real_0_is_zero_f64 : forall (f:t1), (0%R = (t'real1 f)) -> is_zero1 f.

Axiom f32_to_f64 : forall (f:t), ((to_f64 (t'real f)) = (to_float64 RNE f)).

Axiom f64_to_f32 :
  forall (f:t1), ((to_f32 (t'real1 f)) = (to_float32 RNE f)).

(* Why3 assumption *)
Definition finite (x:Reals.Rdefinitions.R) : Prop :=
  t'isFinite (to_f32 x) /\ t'isFinite1 (to_f64 x).

Parameter eq_f32b: t -> t -> Init.Datatypes.bool.

Axiom eq_f32b'def :
  forall (x:t) (y:t),
  (eq x y -> ((eq_f32b x y) = Init.Datatypes.true)) /\
  (~ eq x y -> ((eq_f32b x y) = Init.Datatypes.false)).

Parameter eq_f64b: t1 -> t1 -> Init.Datatypes.bool.

Axiom eq_f64b'def :
  forall (x:t1) (y:t1),
  (eq1 x y -> ((eq_f64b x y) = Init.Datatypes.true)) /\
  (~ eq1 x y -> ((eq_f64b x y) = Init.Datatypes.false)).

(* Why3 assumption *)
Definition ne_f32 (x:t) (y:t) : Prop := ~ eq x y.

(* Why3 assumption *)
Definition ne_f64 (x:t1) (y:t1) : Prop := ~ eq1 x y.

Parameter ne_f32b: t -> t -> Init.Datatypes.bool.

Axiom ne_f32b'def :
  forall (x:t) (y:t),
  (ne_f32 x y -> ((ne_f32b x y) = Init.Datatypes.true)) /\
  (~ ne_f32 x y -> ((ne_f32b x y) = Init.Datatypes.false)).

Parameter ne_f64b: t1 -> t1 -> Init.Datatypes.bool.

Axiom ne_f64b'def :
  forall (x:t1) (y:t1),
  (ne_f64 x y -> ((ne_f64b x y) = Init.Datatypes.true)) /\
  (~ ne_f64 x y -> ((ne_f64b x y) = Init.Datatypes.false)).

Parameter le_f32b: t -> t -> Init.Datatypes.bool.

Axiom le_f32b'def :
  forall (x:t) (y:t),
  (le x y -> ((le_f32b x y) = Init.Datatypes.true)) /\
  (~ le x y -> ((le_f32b x y) = Init.Datatypes.false)).

Parameter le_f64b: t1 -> t1 -> Init.Datatypes.bool.

Axiom le_f64b'def :
  forall (x:t1) (y:t1),
  (le1 x y -> ((le_f64b x y) = Init.Datatypes.true)) /\
  (~ le1 x y -> ((le_f64b x y) = Init.Datatypes.false)).

Parameter lt_f32b: t -> t -> Init.Datatypes.bool.

Axiom lt_f32b'def :
  forall (x:t) (y:t),
  (lt x y -> ((lt_f32b x y) = Init.Datatypes.true)) /\
  (~ lt x y -> ((lt_f32b x y) = Init.Datatypes.false)).

Parameter lt_f64b: t1 -> t1 -> Init.Datatypes.bool.

Axiom lt_f64b'def :
  forall (x:t1) (y:t1),
  (lt1 x y -> ((lt_f64b x y) = Init.Datatypes.true)) /\
  (~ lt1 x y -> ((lt_f64b x y) = Init.Datatypes.false)).

Parameter model_f32: t -> Reals.Rdefinitions.R.

(* Why3 assumption *)
Definition delta_f32 (f:t) : Reals.Rdefinitions.R :=
  Reals.Rbasic_fun.Rabs ((t'real f) - (model_f32 f))%R.

(* Why3 assumption *)
Definition error_f32 (f:t) : Reals.Rdefinitions.R :=
  ((delta_f32 f) / (Reals.Rbasic_fun.Rabs (model_f32 f)))%R.

Parameter model_f64: t1 -> Reals.Rdefinitions.R.

(* Why3 assumption *)
Definition delta_f64 (f:t1) : Reals.Rdefinitions.R :=
  Reals.Rbasic_fun.Rabs ((t'real1 f) - (model_f64 f))%R.

(* Why3 assumption *)
Definition error_f64 (f:t1) : Reals.Rdefinitions.R :=
  ((delta_f64 f) / (Reals.Rbasic_fun.Rabs (model_f64 f)))%R.

Axiom exp_pos :
  forall (x:Reals.Rdefinitions.R), (0%R < (Reals.Rtrigo_def.exp x))%R.

(* Why3 assumption *)
Definition L_exponent (x:Reals.Rdefinitions.R) : Numbers.BinNums.Z :=
  floor
  ((Reals.Rpower.ln (Reals.Rbasic_fun.Rabs x)) / (Reals.Rpower.ln 2%R))%R.

Parameter L_signbit: Reals.Rdefinitions.R -> Numbers.BinNums.Z.

Axiom L_signbit'def :
  forall (x:Reals.Rdefinitions.R),
  ((0%R <= x)%R -> ((L_signbit x) = 0%Z)) /\
  (~ (0%R <= x)%R -> ((L_signbit x) = 1%Z)).

(* Why3 assumption *)
Definition L_mantissa_64bit (x:Reals.Rdefinitions.R) : Numbers.BinNums.Z :=
  floor
  (4503599627370496%R *
   ((-1%R)%R +
    ((Reals.Rbasic_fun.Rabs x) /
     (Reals.Rpower.Rpower 2%R (real_of_int (L_exponent x))))%R)%R)%R.

(* Why3 assumption *)
Definition L_make_double (s:Numbers.BinNums.Z) (e:Numbers.BinNums.Z)
    (m:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  let r := real_of_int (4503599627370496%Z + m)%Z in
  ((Reals.Rpower.Rpower (-1%R)%R (real_of_int s)) *
   (r /
    (Reals.Rpower.Rpower 2%R
     (real_of_int
      ((floor ((Reals.Rpower.ln r) / (Reals.Rpower.ln 2%R))%R) +
       ((-1%Z)%Z * e)%Z)%Z)))%R)%R.

Axiom Q_exponent_signbit_independent :
  forall (x:Reals.Rdefinitions.R),
  ((L_exponent (Reals.Rbasic_fun.Rabs x)) = (L_exponent x)).

Axiom Q_floor_eq :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (y = x) ->
  ((floor y) = (floor x)).

Axiom Q_floor_sum :
  forall (x:Reals.Rdefinitions.R) (y:Numbers.BinNums.Z),
  ((y + (floor x))%Z = (floor (x + (real_of_int y))%R)).

Axiom Q_mantissa_hidden_bit :
  forall (x:Reals.Rdefinitions.R),
  ((4503599627370496%Z + (L_mantissa_64bit x))%Z =
   (floor
    (4503599627370496%R *
     ((Reals.Rbasic_fun.Rabs x) /
      (Reals.Rpower.Rpower 2%R (real_of_int (L_exponent x))))%R)%R)).

Axiom Q_mantissa_signbit_independent :
  forall (x:Reals.Rdefinitions.R),
  ((L_mantissa_64bit (Reals.Rbasic_fun.Rabs x)) = (L_mantissa_64bit x)).

Axiom Q_make_double_help :
  forall (x:Reals.Rdefinitions.R), ~ (x = 0%R) ->
  ((t'real1 (to_f64 x)) = x) ->
  ((floor
    ((Reals.Rpower.ln
      (real_of_int (4503599627370496%Z + (L_mantissa_64bit x))%Z))
     / (Reals.Rpower.ln 2%R))%R)
   = 52%Z).

Axiom Q_make_double_help2 :
  forall (x:Reals.Rdefinitions.R),
  let r :=
  ((Reals.Rbasic_fun.Rabs x) /
   (Reals.Rpower.Rpower 2%R (real_of_int (L_exponent x))))%R in
  ~ (x = 0%R) -> (1%R <= r)%R /\ (r < 2%R)%R.

Axiom Q_mantissa_is_int :
  forall (x:Reals.Rdefinitions.R), ~ (x = 0%R) ->
  ((t'real1 (to_f64 x)) = x) ->
  ((4503599627370496%R *
    ((Reals.Rbasic_fun.Rabs x) /
     (Reals.Rpower.Rpower 2%R (real_of_int (L_exponent x))))%R)%R
   = (real_of_int (4503599627370496%Z + (L_mantissa_64bit x))%Z)).

Axiom Q_make_double_signbit :
  forall (x:Reals.Rdefinitions.R), ~ (x = 0%R) ->
  ((t'real1 (to_f64 x)) = x) ->
  (((Reals.Rbasic_fun.Rabs x) *
    (Reals.Rpower.Rpower (-1%R)%R (real_of_int (L_signbit x))))%R
   = x).

Axiom Q_mantissa_exponent_independent :
  forall (x:Reals.Rdefinitions.R), ~ (x = 0%R) ->
  ((L_mantissa_64bit (2%R * x)%R) = (L_mantissa_64bit x)).

Axiom Q_real_abs_div :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (0%R < y)%R ->
  (((Reals.Rbasic_fun.Rabs x) / y)%R = (Reals.Rbasic_fun.Rabs (x / y)%R)).

Axiom Q_real_2__ln :
  forall (x:Reals.Rdefinitions.R), (x = 2%R) -> ~ ((Reals.Rpower.ln x) = 0%R).

Axiom Q_real_2_power_ln :
  forall (x:Reals.Rdefinitions.R), ~ (x = 0%R) ->
  ~ ((Reals.Rpower.Rpower 2%R
      (real_of_int
       (floor
        ((Reals.Rpower.ln (Reals.Rbasic_fun.Rabs x)) /
         (Reals.Rpower.ln 2%R))%R)))
     = 0%R).

Axiom Q_real_2_power_52 :
  forall (x:Reals.Rdefinitions.R), (x = 2%R) ->
  ((Reals.Rpower.Rpower x 52%R) = 4503599627370496%R).

Axiom Q_real_2_power_1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x = 2%R) ->
  (y = 1%R) -> ((Reals.Rpower.Rpower x y) = 2%R).

Axiom Q_real_1_lt_2 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x = 2%R) ->
  (y = 1%R) -> (y < x)%R.

Axiom Q_real_0_lt_2 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (x = 2%R) ->
  (y = 0%R) -> (y < x)%R.

Axiom Q_real_leq_geq :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R), (y <= x)%R ->
  (x <= y)%R -> (y = x).

(* Why3 goal *)
Theorem wp_goal :
  forall (r:Reals.Rdefinitions.R), ~ (r = 0%R) ->
  ((t'real1 (to_f64 r)) = r) ->
  ((L_make_double (L_signbit r) (L_exponent r) (L_mantissa_64bit r)) = r).
(* Why3 intros r h1 h2. *)
Proof.
  Require Import Lia.
  Require Import Frama_Floor.

  intros.
  unfold L_make_double.
  rewrite Q_mantissa_hidden_bit.
  rewrite Q_mantissa_is_int.
  (* unfold L_exponent, L_mantissa_64bit, L_make_double, L_exponent. *)
  unfold real_of_int.
  rewrite Floor_int.
  rewrite Q_make_double_help.
  rewrite FromInt.Add.
  rewrite FromInt.Add.
  rewrite Rpower.Rpower_plus.
  rewrite <- FromInt.Add.
  rewrite <- Q_mantissa_is_int.
  rewrite Real.infix_sl'def.
  rewrite Real.infix_sl'def.
  unfold real_of_int.
  rewrite Q_real_2_power_52 at 1.
  rewrite Ropp_Ropp_IZR.
  rewrite Rpower.Rpower_Ropp.
  field_simplify.
  rewrite Real.Comm1.
  rewrite Q_make_double_signbit.
  all: try auto.
  apply Rgt_not_eq.
  apply Rlt_gt.
  apply PowerReal.Pow_pos.
  apply Q_real_0_lt_2; auto.

Qed.

